https://www.reddit.com/r/ClaudeAI/comments/1oivjvm/claude_code_is_a_beast_tips_from_6_months_of/

# Claude Code는 진짜 괴물입니다 – 6개월간 ‘빡세게’ 써보고 올리는 꿀팁

> **게으른 동료들을 위한 꿀팁:** 이 글은 분량이 거의 책 한 권 수준입니다. [Natural Reader](https://www.naturalreaders.com/) 같은 AI TTS 서비스에 던져놓고 귀로 들으시는 걸 추천합니다. :)

**수정 사항 (Edit):**
저장소(Repo) 요청이 정말 많네요. 며칠 내로 하나 파보겠습니다. 지금은 전부 업무용 프로젝트의 일부라, 내용을 새 프로젝트로 옮기고 식별 정보를 지우는 작업이 좀 필요합니다. 준비되면 여기 링크를 올릴게요. 제 프로필을 팔로우해두시면 알림이 갈 겁니다. 따뜻한 댓글들 감사합니다. 평소엔 이런 정보를 공유할 기회가 별로 없는데, 도움이 된다니 기쁘네요.

**최종 수정(?):**
큰맘 먹고 오후 내내 시간을 내서 깃허브 저장소를 만들었습니다. 추가 정보를 담은 포스팅을 [여기]에 올렸으니 확인하시거나, 아니면 바로 소스코드로 가셔도 됩니다.

* 🎯 **Repository:** [diet103/claude-code-infrastructure-showcase](https://github.com/diet103/claude-code-infrastructure-showcase)

---

### 🔍 들어가며 (Disclaimer)

약 6개월 전쯤, Claude Code(이하 CC)를 일주일간 하드코어하게 써본 후기를 올린 적이 있습니다. 이제 그 기간이 6개월로 늘어났고, 그동안 쌓인 팁과 요령, 그리고 의식의 흐름을 여러분과 공유해보려 합니다. 내용이 좀 과하게 길어질 수도 있으니, 커피 한 잔 챙겨서 화장실에 앉든가 아니면 레딧 ‘둠스크롤링’할 때 하시는 루틴대로 마음 단단히 먹고 시작해 봅시다.

미리 말씀드리자면, 이 글의 모든 내용은 현재 저에게 가장 잘 맞는 설정을 공유하는 것일 뿐, **이것이 정답이라거나 유일한 방법이라는 뜻은 아닙니다.** 그저 여러분이 AI 에이전트 코딩 워크플로우를 개선하는 데 영감을 얻으시길 바랄 뿐입니다. 저도 그냥 일개 개발자일 뿐이고, 이건 그냥 제 의견일 뿐이니까요.

참고로 저는 **20x Max 플랜**을 사용 중이라 여러분의 상황과는 조금 다를 수 있습니다. 그리고 소위 말하는 ‘바이브 코딩(vibe-coding, 대충 감으로 코딩하기)’ 팁을 찾으신다면 다른 글을 보시는 게 낫습니다. CC에서 최고의 결과물을 뽑아내고 싶다면 기획, 리뷰, 반복 작업, 다양한 접근 방식 탐색 등을 CC와 **함께** 해나가야 합니다.

### 🚀 핵심 요약 (Quick Overview)

지난 6개월간 CC를 한계까지 밀어붙이며(혼자서 30만 줄의 코드를 새로 짰습니다), 제가 구축한 시스템은 다음과 같습니다:

* **Skills:** 필요할 때 실제로 자동 활성화되는 스킬들
* **Dev Docs Workflow:** Claude가 맥락을 놓치지 않게 만드는 개발 문서 워크플로우
* **PM2 + Hooks:** 에러를 하나도 놓치지 않는 설정
* **Agent Army:** 리뷰, 테스트, 기획을 담당하는 특화된 에이전트 군단

---
### 배경 (Background)

저는 지난 7년 정도 프로덕션 웹 앱을 개발해 온 소프트웨어 엔지니어입니다. 그리고 AI의 물결을 두 팔 벌려 완전히 받아들였죠. AI가 제 일자리를 뺏을 거라는 걱정은 별로 안 합니다. AI는 제 능력을 극대화해 주는 도구니까요. 실제로 클로드(Claude)와 GPT-5 Thinking(추론 모델)을 활용해 프로덕션 앱에 새로운 AI 시스템을 통합하는 온갖 제안서와 기능을 만들어내고 있습니다. AI를 워크플로우에 도입하기 전에는 감히 시간 낼 엄두도 못 냈던 프로젝트들이죠. 덕분에 회사에서 고용 안정성도 확실히 챙겼고, 다른 사람들보다 AI 도입 속도가 1년 정도는 앞서 있다 보니 어느새 'AI 구루' 대접을 받고 있습니다.

자신감이 붙은 저는 회사 내부 도구로 쓰이는 웹 앱 중 하나를 대대적으로 리디자인/리팩토링하겠다고 제안했습니다. 이건 제가 인턴 시절(약 7년 전)에 만든 프로젝트를 기반으로, 4년 전쯤 대학생들이 포크(fork)해서 만든 좀 엉망인 프로젝트였죠. 스테이크홀더들을 설득하려고 이 꽤 규모 있는 프로젝트(약 10만 줄의 코드)의 전체 리디자인을 혼자서 몇 달 안에 끝내겠다고 장담해 버렸는데, 지금 생각하면 좀 무모했던 것 같습니다. CC(Claude Code)의 도움을 받더라도 야근은 필수라는 걸 알고는 있었지만, 이 프로젝트가 성공하면 수많은 수작업이 자동화되어 회사 사람들의 시간을 엄청나게 아껴줄 거라는 확신이 있었거든요.

그로부터 6개월이 지났습니다... 네, 그런 일정을 잡는 게 아니었습니다. 이 일을 끝내기 위해 클로드의 한계뿐만 아니라 제 정신력의 한계까지 시험해야 했거든요. 기존 프론트엔드는 완전히 갈아엎었습니다. 모든 게 너무 구식이었고, 저는 최신 기술을 마음껏 써보고 싶었거든요. **React 16 JS → React 19 TypeScript**, **React Query v2 → TanStack Query v5**, **HashRouter 기반의 React Router v4 → 파일 기반 라우팅의 TanStack Router**, **MUI v4 → MUI v7**까지, 베스트 프랙티스를 철저히 따르며 작업했습니다. 이제 프로젝트 규모는 30~40만 줄에 달하고, 제 예상 수명은 한 5년쯤 줄어든 것 같네요. 마침내 테스트 단계에 들어갔는데, 결과물은 정말 만족스럽습니다.

이 프로젝트는 원래 감당 안 되는 기술 부채와 제로(0)에 가까운 테스트 커버리지, 최악의 개발자 경험(테스트 한 번 하기가 악몽 수준), 그리고 온갖 엉성한 코드들로 가득했습니다. 저는 적절한 테스트 커버리지를 확보하고 기술 부채를 관리 가능한 수준으로 정리했으며, 테스트 데이터 생성을 위한 CLI 도구와 프론트엔드 기능을 테스트할 수 있는 개발 모드까지 구현해 이 모든 문제를 해결했습니다. 이 과정을 거치며 저는 CC의 능력이 어느 정도인지, 그리고 무엇을 기대할 수 있는지 확실히 알게 되었습니다.

### 품질과 일관성에 대하여 (A Note on Quality and Consistency)

포럼이나 토론 게시판을 보면 사용량 제한에 대한 불만이나, 시간이 갈수록 출력 품질이 떨어진다는 우려가 공통적으로 보입니다. 우선 분명히 짚고 넘어갈게요. 저는 그런 경험들을 부정하거나 "그냥 네가 잘못 쓰고 있는 거야"라고 말하려는 게 아닙니다. 사람마다 사용 사례와 상황이 다르고, 타당한 우려는 충분히 목소리를 낼 가치가 있으니까요.

그럼에도 불구하고, 저는 저에게 효과적이었던 방법을 공유하고 싶습니다. 제 경험상 CC의 출력은 지난 몇 달 동안 오히려 상당히 개선되었는데, 이는 제가 계속해서 다듬어온 워크플로우 덕분이라고 믿습니다. 여러분이 제 시스템에서 작은 영감이라도 얻어 CC 워크플로우에 통합한다면, 여러분이 만족할 만한 양질의 결과물을 얻을 확률이 훨씬 높아질 거라 기대합니다.

솔직해집시다. 클로드가 완전히 헛다리를 짚거나 별로인 코드를 내놓을 때가 분명히 있습니다. 여기에는 여러 이유가 있죠. 첫째, AI 모델은 **확률적(stochastic)**입니다. 즉, 같은 입력을 넣어도 결과가 크게 달라질 수 있다는 뜻입니다. 가끔은 운이 나빠서 본인 잘못이 없는데도 형편없는 결과가 나올 수 있습니다. 또 다른 이유는 **프롬프트의 구조** 때문입니다. 모델은 말을 아주 문자 그대로 받아들이기 때문에, 단어 선택이 조금만 달라져도 결과가 확연히 차이 날 수 있습니다. 모호한 표현이나 잘못된 단어 선택은 훨씬 저급한 결과로 이어집니다.

### 때로는 직접 개입해야 합니다 (Sometimes You Just Need to Step In)

AI가 놀랍긴 하지만 마법은 아닙니다. 패턴 인식이나 인간의 직관이 훨씬 앞서는 특정 문제들이 분명히 존재합니다. 클로드가 2분이면 해결할 수 있는 문제를 가지고 30분 동안 끙끙대는 걸 보고 있다면, **그냥 직접 고치세요.** 부끄러운 일이 아닙니다. 아이에게 자전거 타는 법을 가르치는 것과 비슷합니다. 다시 손을 놓기 전에 잠시 핸들을 잡아 중심을 잡아줘야 할 때가 있는 법이죠.

특히 논리 퍼즐이나 현실 세계의 상식이 필요한 문제에서 이런 현상이 두드러집니다. AI는 많은 일을 무식하게 밀어붙여(brute-force) 해결할 수 있지만, 인간이 훨씬 빠르게 "이해"하는 영역이 있습니다. 고집을 피우거나 "AI가 다 해줘야지"라는 잘못된 생각 때문에 시간을 낭비하지 마세요. 직접 개입해서 수정하고 계속 나아가십시오.

저도 프롬프트를 엉망으로 던질 때가 많습니다. 보통 하루 일과가 끝나갈 무렵 귀찮아져서 프롬프트에 공을 들이지 않을 때 그렇죠. 결과는 정직하게 나타납니다. 그러니 다음에 출력 품질이 예전만 못하다고 느껴져서 "앤스로픽(Anthropic)이 클로드를 몰래 너프한 거 아냐?"라는 생각이 든다면, 잠시 멈춰서 자신의 프롬프팅 방식을 되돌아보길 권합니다.

**프롬프트를 자주 다시 던지세요(Re-prompt).** `ESC`를 두 번 누르면 이전 프롬프트들을 불러와서 특정 시점부터 다시 시작할 수 있습니다. 무엇을 원하지 않는지 알게 된 상태에서 똑같은 프롬프트를 다시 주는 것만으로도 얼마나 더 나은 결과를 얻을 수 있는지 알면 놀라실 겁니다. 출력 품질이 떨어지는 데는 여러 이유가 있을 수 있으니, 스스로를 돌아보고 원하는 결과를 얻기 위해 최선의 환경(컨텍스트)을 제공하고 있는지 고민해 보는 것이 좋습니다.

어느 현자가 말했듯 말이죠.

> "클로드가 당신을 위해 무엇을 할 수 있는지 묻지 말고, 당신이 클로드에게 어떤 컨텍스트를 줄 수 있는지 물어라." — *어떤 현자*

자, 이제 훈수는 여기까지 하고 진짜 알맹이로 들어가 보겠습니다.

### 나의 시스템 (My System)

지난 6개월간 CC 워크플로우에 정말 많은 변화를 줬고, 제 기준에서는 결과가 아주 훌륭했습니다.

#### 스킬 자동 활성화 시스템 (Skills Auto-Activation System) — **완전 게임 체인저!**

이 부분은 제 Claude Code 사용 방식을 완전히 바꿔놓았기 때문에 별도의 섹션으로 다룰 가치가 충분합니다.

**문제점 (The Problem)**
앤스로픽이 'Skills' 기능을 출시했을 때 저는 "이거 대박인데?"라고 생각했습니다. 거대한 코드베이스 전체에서 일관성을 유지할 수 있도록 클로드가 참조할 수 있는 휴대용, 재사용 가능 가이드라인을 가진다는 아이디어는 완벽해 보였거든요. 저는 클로드와 함께 프론트엔드/백엔드 개발, 데이터베이스 작업, 워크플로우 관리 등을 위한 포괄적인 스킬들을 작성하는 데 꽤 많은 시간을 투자했습니다. 베스트 프랙티스, 패턴, 예시들이 수천 줄에 달했죠.

그런데... 아무 일도 일어나지 않았습니다. 스킬 설명에 적힌 키워드를 그대로 사용해도 클로드는 요지부동이었습니다. 해당 스킬이 작동해야 마땅한 파일들을 작업해도 아무런 반응이 없었죠. 잠재력은 눈에 보이는데, 정작 공들여 만든 스킬들은 그저 **비싼 장식품**처럼 자리만 차지하고 있으니 정말 답답했습니다.

**"아하!" 모먼트 (The "Aha!" Moment)**
그때 **훅(hooks)**을 사용하자는 아이디어가 떠올랐습니다. 클로드가 스킬을 자동으로 쓰지 않는다면, 무언가를 하기 전에 관련 스킬이 있는지 **강제로** 체크하게 만드는 시스템을 구축하면 어떨까?

그래서 저는 Claude Code의 훅 시스템을 파고들어 TypeScript 훅을 이용한 다층 자동 활성화 아키텍처를 만들었습니다. 그리고 이게 진짜 먹히더군요!

**작동 방식 (How It Works)**
두 개의 메인 훅을 생성했습니다:

1. **UserPromptSubmit 훅** (클로드가 사용자의 메시지를 보기 **전**에 실행):
* 사용자의 프롬프트에서 키워드와 의도(intent) 패턴을 분석합니다.
* 어떤 스킬이 관련 있는지 체크합니다.
* 클로드의 컨텍스트에 포맷팅된 리마인드를 주입합니다.
* 이제 제가 "레이아웃 시스템이 어떻게 작동해?"라고 물으면, 클로드는 제 질문을 읽기도 전에 **"🎯 스킬 활성화 체크 - project-catalog-developer 스킬을 사용하세요"**라는 문구를 먼저 보게 됩니다. (참고로 project catalog는 제 프로젝트 프론트엔드의 복잡한 데이터 그리드 기능입니다.)


2. **Stop Event 훅** (클로드가 답변을 마친 **후**에 실행):
* 수정된 파일들을 분석합니다.
* 위험한 패턴(try-catch 블록, DB 작업, 비동기 함수 등)이 있는지 체크합니다.
* 부드러운 자가 점검 리마인드를 표시합니다.
* "에러 핸들링을 추가했나요? Prisma 작업이 리포지토리 패턴을 따르고 있나요?" 같은 식이죠.
* 작업을 방해하지 않으면서도 클로드가 흐름을 놓치지 않게 계속 상기시켜 줍니다.



**skill-rules.json 설정 (Configuration)**
모든 스킬을 정의하는 중앙 설정 파일을 만들었습니다:

* **키워드(Keywords):** 명시적인 주제 매칭 ("layout", "workflow", "database")
* **의도 패턴(Intent patterns):** 특정 동작을 포착하는 정규표현식 (`(create|add).*?(feature|route)`)
* **파일 경로 트리거:** 수정 중인 파일의 경로에 따라 활성화
* **내용 트리거:** 파일에 특정 패턴(Prisma import, controller 등)이 포함된 경우 활성화

Example snippet:

```
{
  "backend-dev-guidelines": {
    "type": "domain",
    "enforcement": "suggest",
    "priority": "high",
    "promptTriggers": {
      "keywords": ["backend", "controller", "service", "API", "endpoint"],
      "intentPatterns": [
        "(create|add).*?(route|endpoint|controller)",
        "(how to|best practice).*?(backend|API)"
      ]
    },
    "fileTriggers": {
      "pathPatterns": ["backend/src/**/*.ts"],
      "contentPatterns": ["router\\.", "export.*Controller"]
    }
  }
}
```

### 결과 (The Results)

이제 제가 백엔드 코드를 작업할 때면, 클로드는 자동으로 다음과 같은 과정을 거칩니다:

* 제 프롬프트를 읽기도 전에 **스킬 제안(Skill suggestion)을 먼저 확인**합니다.
* 관련된 **가이드라인을 로드**합니다.
* 실제로 패턴을 **일관되게 준수**하며 코드를 짭니다.
* 마지막에 부드러운 리마인드를 통해 **스스로 결과물을 체크**합니다.

결과는 그야말로 **천지차이**입니다. 더 이상 일관성 없는 코드가 나오지 않습니다. "잠깐, 클로드가 또 옛날 패턴을 썼네?"라며 당황할 일도 없습니다. 매번 가이드라인을 확인하라고 일일이 말해줄 필요도 없어졌죠.

---

### 앤스로픽 베스트 프랙티스 따라가기 (고생 끝에 깨달은 것들)

자동 활성화 시스템을 성공시킨 후 좀 더 깊이 파고들다 보니, 앤스로픽의 공식 베스트 프랙티스 문서를 발견했습니다. 알고 보니 제가 잘못하고 있었더군요. 공식적으로는 메인 `SKILL.md` 파일을 **500줄 이하**로 유지하고, 리소스 파일을 활용한 **'단계적 공개(progressive disclosure)'** 방식을 권장하고 있었습니다.

아차 싶었죠. 제 'frontend-dev-guidelines' 스킬은 1,500줄이 넘었거든요. 1,000줄이 넘는 다른 스킬들도 몇 개 더 있었고요. 이렇게 거대한 단일 파일들은 "필요한 것만 로드한다"는 스킬의 목적 자체를 무색하게 만들고 있었습니다.

그래서 모든 구조를 다시 잡았습니다:

* **frontend-dev-guidelines:** 398줄의 메인 파일 + 10개의 리소스 파일
* **backend-dev-guidelines:** 304줄의 메인 파일 + 11개의 리소스 파일

이제 클로드는 처음에 가벼운 메인 파일만 로드하고, 정말 필요할 때만 상세한 리소스 파일들을 가져옵니다. 덕분에 대부분의 쿼리에서 **토큰 효율성이 40~60%나 개선**되었습니다.

### 내가 만든 스킬들 (Skills I've Created)

현재 제가 운용 중인 스킬 라인업은 다음과 같습니다.

#### 가이드라인 및 베스트 프랙티스:

* **backend-dev-guidelines:** Routes → Controllers → Services → Repositories로 이어지는 계층 구조 관리
* **frontend-dev-guidelines:** React 19, MUI v7, TanStack Query/Router 패턴 준수
* **skill-developer:** 더 많은 스킬을 만들기 위한 메타 스킬

#### 도메인 특화 스킬:

* **workflow-developer:** 복잡한 워크플로우 엔진 패턴 처리
* **notification-developer:** 이메일 및 알림 시스템 관련
* **database-verification:** 컬럼명 오류 방지 (**실제로 수정을 차단하는 가드레일 역할!**)
* **project-catalog-developer:** 데이터그리드(DataGrid) 레이아웃 시스템

이 모든 스킬은 제가 작업 중인 내용에 따라 자동으로 활성화됩니다. 모든 패턴을 완벽하게 기억하고 있는 시니어 개발자가 클로드의 어깨너머를 지켜보고 있는 것과 다름없죠.

---

### 이것이 중요한 이유 (Why This Matters)

**스킬 + 훅 도입 전:**

* 새로운 패턴을 문서화해 둬도 클로드가 자꾸 옛날 패턴을 사용함
* 매번 클로드에게 `BEST_PRACTICES.md`를 확인하라고 수동으로 말해줘야 했음
* 30만 줄이 넘는 코드베이스 곳곳에 일관성 없는 코드가 발생함
* 클로드의 "창의적인 해석"을 수정하는 데 너무 많은 시간을 낭비함

**스킬 + 훅 도입 후:**

* 일관된 패턴이 자동으로 강제됨
* 제가 코드를 확인하기도 전에 클로드가 스스로 수정함
* 가이드라인이 철저히 준수되고 있다는 확신이 생김
* 리뷰와 수정에 드는 시간이 획기적으로 줄어듦

이미 정립된 패턴이 있는 대규모 코드베이스에서 작업 중이라면, 이 시스템을 강력하게 추천합니다. 초기 설정에 며칠 걸리긴 했지만, 그 과정에서 들인 노력은 이미 열 배 이상의 가치로 돌아왔습니다.

---

### CLAUDE.md와 문서화의 진화 (CLAUDE.md and Documentation Evolution)

6개월 전 쓴 글에서 "규칙(Rules)은 당신의 가장 친한 친구"라고 말했었고, 그 생각은 지금도 변함없습니다. 하지만 제 `CLAUDE.md` 파일은 금세 감당할 수 없을 정도로 커졌고, 너무 많은 일을 하려다 보니 비효율적이었습니다. 게다가 1,400줄이 넘는 거대한 `BEST_PRACTICES.md` 파일도 있었는데, 클로드는 이 파일을 읽을 때도 있고 완전히 무시할 때도 있었습니다.

그래서 클로드와 함께 오후 시간을 내어 모든 것을 새로운 시스템으로 통합하고 재조직했습니다. 변화된 내용은 다음과 같습니다.

#### 스킬로 옮겨진 내용들

기존에 `BEST_PRACTICES.md`에 포함되어 있던 다음 내용들을 모두 스킬로 이전했습니다:

* TypeScript 표준
* React 패턴 (Hooks, Components, Suspense)
* 백엔드 API 패턴 (Routes, Controllers, Services)
* 에러 핸들링 (Sentry 연동)
* 데이터베이스 패턴 (Prisma 사용법)
* 테스트 가이드라인
* 성능 최적화

이제 이 모든 것이 **스킬**에 담겨 있고, 자동 활성화 훅이 클로드로 하여금 이를 반드시 사용하게 만듭니다. 클로드가 `BEST_PRACTICES.md`를 확인해 주길 기도할 필요가 없어진 거죠.

### CLAUDE.md에 남겨둔 것들 (What Stayed in CLAUDE.md)

현재 `CLAUDE.md`는 **프로젝트 고유의 정보**에만 아주 예리하게 집중하고 있으며, 분량도 약 200줄 정도로 대폭 줄었습니다.

* **주요 명령어:** (`pnpm pm2:start`, `pnpm build` 등)
* **서비스별 설정**
* **작업 관리 워크플로우:** (개발 문서 시스템)
* **인증된 라우트 테스트 방법**
* **워크플로우 드라이런(Dry-run) 모드**
* **브라우저 도구 설정**

### 새로운 구조 (The New Structure)
```
Root CLAUDE.md (100 lines)
├── Critical universal rules
├── Points to repo-specific claude.md files
└── References skills for detailed guidelines

Each Repo's claude.md (50-100 lines)
├── Quick Start section pointing to:
│   ├── PROJECT_KNOWLEDGE.md - Architecture & integration
│   ├── TROUBLESHOOTING.md - Common issues
│   └── Auto-generated API docs
└── Repo-specific quirks and commands
```
**핵심 비결:** 스킬(Skills)이 "코드를 작성하는 방법"에 대한 모든 가이드라인을 담당하고, `CLAUDE.md`는 "이 특정 프로젝트가 작동하는 방식"을 담당하게 한 것입니다. 역시 관심사 분리(Separation of concerns)가 답이네요.

### 개발 문서 시스템 (Dev Docs System)

스킬 시스템을 제외하고, 제가 CC를 쓰면서 얻은 성과에 가장 큰 영향을 준 것이 바로 이 시스템입니다. 클로드는 마치 자신감은 하늘을 찌르는데 건망증은 역대급인 주니어 개발자 같아서, 자기가 뭘 하고 있는지 너무 쉽게 잊어버리곤 하거든요. 이 시스템은 바로 그런 단점들을 해결하는 데 목적이 있습니다.

제 `CLAUDE.md` 파일에 포함된 개발 문서 섹션은 다음과 같습니다:
```
### Starting Large Tasks

When exiting plan mode with an accepted plan: 1.**Create Task Directory**:
mkdir -p ~/git/project/dev/active/[task-name]/

2.**Create Documents**:

- `[task-name]-plan.md` - The accepted plan
- `[task-name]-context.md` - Key files, decisions
- `[task-name]-tasks.md` - Checklist of work

3.**Update Regularly**: Mark tasks complete immediately

### Continuing Tasks

- Check `/dev/active/` for existing tasks
- Read all three files before proceeding
- Update "Last Updated" timestamps
```
이 문서들은 모든 기능 개발이나 대규모 작업 시 항상 작성됩니다. 이 시스템을 도입하기 전에는 클로드가 갑자기 맥락을 놓치고는, 30분 전에 계획했던 것과는 완전히 딴판인 작업을 하고 있다는 사실을 뒤늦게 깨닫는 일이 허다했습니다. 어떤 이유에서든 중간에 다른 길로 새버렸기 때문이죠.

### 나의 기획 프로세스 (My Planning Process)

제 프로세스는 기획(Planning)에서 시작합니다. **기획이 전부입니다.** 만약 클로드에게 무언가를 구현해달라고 하기 전에 최소한 '플래닝 모드'라도 쓰고 있지 않다면, 여러분은 아주 고통스러운 시간을 보내게 될 겁니다. 아시겠죠? 건축업자를 불러서 도면도 안 그리고 바로 집 증축 공사를 시작하게 하지는 않잖아요.

기능 개발을 시작할 때, 결국 클로드가 마크다운 파일에 계획을 작성하게 할 것이더라도 일단은 플래닝 모드로 진입합니다. 플래닝 모드 설정이 필수인지는 확실하지 않지만, 제 체감상 플래닝 모드가 코드베이스를 분석하고 계획을 세우는 데 필요한 정확한 컨텍스트를 파악하는 성능이 더 뛰어난 것 같거든요.

저는 기획에 특화된 `strategic-plan-architect`라는 서브에이전트를 만들었습니다. 이 녀석은 정말 기획의 괴물입니다. 하는 일은 다음과 같습니다:

* 컨텍스트를 효율적으로 수집
* 프로젝트 구조 분석
* 요약, 단계, 작업, 리스크, 성공 지표, 일정을 포함한 포괄적인 구조화된 계획 수립
* 계획(plan), 컨텍스트(context), 작업 체크리스트(tasks checklist)라는 세 개의 파일을 자동으로 생성

그런데 에이전트의 출력 결과를 실시간으로 볼 수 없다는 점이 정말 짜증 났습니다. 더 짜증 나는 건, 제시한 계획에 "No"라고 하면 에이전트가 계획을 수정하는 게 아니라 그냥 죽어버린다는 거였죠. 그래서 저는 메인 CC 인스턴스에서 사용할 수 있도록 동일한 프롬프트를 가진 커스텀 슬래시 명령어(`/dev-docs`)를 만들었습니다.

클로드가 멋진 계획을 뽑아내면, 시간을 들여 **철저하게 검토합니다.** 이 단계가 정말 중요합니다. 계획을 완벽히 이해하려고 노력해 보세요. 클로드가 말도 안 되는 실수를 했거나, 요청한 작업의 아주 핵심적인 부분을 잘못 이해하고 있는 걸 발견할 때가 생각보다 많아서 놀라실 겁니다.

플래닝 모드를 종료하고 나면 컨텍스트가 15% 이하로 남는 경우가 허다합니다. 하지만 괜찮습니다. 새로 시작하는 데 필요한 모든 것을 '개발 문서(dev docs)'에 다 때려 넣을 거니까요. 클로드는 보통 앞뒤 안 가리고 무작정 구현에 달려드는 걸 좋아하는데, 저는 즉시 `ESC` 키를 눌러 중단시킨 뒤 `/dev-docs` 명령어를 실행합니다. 이 명령어는 승인된 계획을 가져와서 세 개의 파일을 생성하며, 컨텍스트가 충분히 남아 있다면 부족한 부분을 채우기 위해 추가적인 조사를 수행하기도 합니다.

이 과정이 끝나면, 클로드가 자동 압축(auto-compaction)을 거치더라도 길을 잃거나 하던 일을 잊어버리지 않고 기능을 완벽하게 구현할 수 있는 준비가 끝난 겁니다. 저는 클로드에게 주기적으로 작업 상태와 컨텍스트 파일을 업데이트하라고 상기시켜 줍니다. 현재 세션의 컨텍스트가 부족해지면 그냥 `/update-dev-docs` 명령어를 실행합니다. 그러면 클로드는 대화를 압축하기 전에 관련 컨텍스트(다음 단계 포함)를 기록하고, 완료된 작업을 표시하거나 새 작업을 추가합니다. 그러면 저는 새 세션에서 "계속해(continue)"라고만 말하면 됩니다.

구현 단계에서는 기능의 규모에 따라 클로드에게 한 번에 한두 섹션씩만 구현하라고 명시적으로 지시합니다. 그래야 각 작업 사이사이에 코드를 직접 리뷰할 기회를 가질 수 있거든요. 그리고 주기적으로 서브에이전트가 변경 사항을 리뷰하게 해서 큰 실수를 초기에 잡아냅니다. 클로드에게 자신의 코드를 스스로 리뷰하게 시키지 않고 있다면, 꼭 해보시길 강력히 추천합니다. 치명적인 에러, 누락된 구현, 일관성 없는 코드, 보안 결함 등을 잡아내는 데 정말 큰 도움이 됩니다.

### PM2 프로세스 관리 (백엔드 디버깅의 게임 체인저)

이건 비교적 최근에 도입한 방식인데, 백엔드 이슈를 디버깅하는 게 말도 안 되게 쉬워졌습니다.

**문제점 (The Problem)**
제 프로젝트에는 7개의 백엔드 마이크로서비스가 동시에 돌아가고 있습니다. 문제는 서비스가 실행 중일 때 클로드가 로그를 볼 방법이 없었다는 점이었죠. "이메일 서비스에 무슨 문제가 있어?"라고 물어봐도, 제가 수동으로 로그를 복사해서 채팅창에 붙여넣지 않는 한 클로드는 로그를 확인할 수 없었습니다.

**과도기적 해결책 (The Intermediate Solution)**
한동안은 각 서비스가 `devLog` 스크립트를 사용해 타임스탬프가 찍힌 로그 파일에 출력하도록 했습니다. 이게 돌아가긴 했지만... 그냥 그랬습니다. 로그가 실시간이 아니었고, 서비스가 죽어도 자동으로 재시작되지 않았으며, 이 모든 걸 관리하는 게 고역이었죠.

**진정한 해결책: PM2 (The Real Solution: PM2)**
그러다 PM2를 발견했고, 이건 그야말로 게임 체인저였습니다. 모든 백엔드 서비스가 단 하나의 명령어 `pnpm pm2:start`로 PM2를 통해 실행되도록 설정했습니다.

**이 설정을 통해 얻은 이점들:**

* 각 서비스는 전용 로그 파일을 가진 관리형 프로세스로 실행됩니다.
* 클로드가 개별 서비스의 로그를 실시간으로 쉽게 읽을 수 있습니다.
* 크래시(Crash) 발생 시 자동으로 재시작됩니다.
* `pm2 logs`를 통한 실시간 모니터링이 가능합니다.
* `pm2 monit`으로 메모리 및 CPU 사용량을 모니터링할 수 있습니다.
* 서비스 관리가 매우 쉬워졌습니다 (`pm2 restart email`, `pm2 stop all` 등).

**PM2 설정 내역:**
```
// ecosystem.config.jsmodule.exports = {
  apps: [
    {
      name: 'form-service',
      script: 'npm',
      args: 'start',
      cwd: './form',
      error_file: './form/logs/error.log',
      out_file: './form/logs/out.log',
    },
// ... 6 more services
  ]
};
```

Before PM2:
```
Me: "The email service is throwing errors"
Me: [Manually finds and copies logs]
Me: [Pastes into chat]
Claude: "Let me analyze this..."
```

The debugging workflow now:
```
Me: "The email service is throwing errors"
Claude: [Runs] pm2 logs email --lines 200
Claude: [Reads the logs] "I see the issue - database connection timeout..."
Claude: [Runs] pm2 restart email
Claude: "Restarted the service, monitoring for errors..."
```

정말 하늘과 땅 차이입니다. 이제 제가 일일이 로그를 퍼다 나르는 ‘인간 로그 배달부’ 노릇을 하지 않아도 클로드가 알아서 자율적으로 이슈를 디버깅할 수 있게 됐죠.

**한 가지 주의할 점:** PM2 환경에서는 핫 리로드(Hot reload)가 지원되지 않습니다. 그래서 프론트엔드는 여전히 `pnpm dev` 명령어로 따로 실행하고 있습니다. 하지만 핫 리로드가 그렇게 자주 필요하지 않은 백엔드 서비스의 경우, PM2는 정말 환상적인 도구입니다.

### 훅 시스템 (Hooks System) — #에러는_남기지_않는다 (#NoMessLeftBehind)

제가 작업 중인 프로젝트는 멀티 루트(multi-root) 구조로, 루트 디렉토리에 약 8개의 서로 다른 저장소(repo)가 있습니다. 프론트엔드 하나와 백엔드용 마이크로서비스 및 유틸리티 7개로 구성되어 있죠. 저는 기능을 개발할 때마다 보통 두세 개의 저장소를 오가며 코드를 수정하곤 합니다.

그런데 저를 끝도 없이 짜증 나게 했던 건, 클로드가 수정한 저장소에서 빌드 명령어를 실행해 에러를 확인하는 걸 자꾸 잊어버린다는 점이었습니다. 제가 확인하지 않으면 십여 개의 TypeScript 에러를 그냥 남겨두곤 했죠. 그러다 몇 시간 뒤에야 클로드가 착한 아이처럼 빌드 스크립트를 돌리고는 이런 출력을 내뱉습니다. "TypeScript 에러가 몇 개 발견되었지만, 지금 작업과는 무관한 것들이니 괜찮습니다!"

아니, 전혀 안 괜찮아, 클로드.

#### 훅 #1: 파일 수정 추적기 (File Edit Tracker)

먼저, 모든 Edit/Write/MultiEdit 작업 후에 실행되는 `post-tool-use` 훅을 만들었습니다. 이 훅은 다음을 기록합니다:

* 어떤 파일이 수정되었는가
* 해당 파일이 어떤 저장소에 속해 있는가
* 타임스탬프

처음에는 수정할 때마다 즉시 빌드를 돌리게 했는데, 이건 멍청할 정도로 비효율적이었습니다. 클로드는 코드를 빨리 고치기 전에 일단 망가뜨려 놓는 경우가 허다하거든요.

#### 훅 #2: 빌드 체크 (Build Checker)

그래서 클로드가 답변을 마칠 때 실행되는 `Stop` 훅을 추가했습니다. 이 훅의 역할은 다음과 같습니다:

* 수정 로그를 읽어 변경된 저장소를 찾습니다.
* 영향을 받은 각 저장소에서 빌드 스크립트를 실행합니다.
* TypeScript 에러를 확인합니다.
* 에러가 5개 미만인 경우: 클로드에게 에러 내용을 보여줍니다.
* 에러가 5개 이상인 경우: 에러 자동 해결 에러전트(auto-error-resolver agent)를 실행하라고 추천합니다.


* 디버깅을 위해 모든 내용을 로그로 남깁니다.

이 시스템을 도입한 이후로, 클로드가 나중에 제가 발견하도록 에러를 방치하는 일은 단 한 번도 없었습니다. 훅이 즉시 에러를 잡아내고, 클로드는 다음 작업으로 넘어가기 전에 에러를 수정합니다.

#### 훅 #3: Prettier 포맷터 (Prettier Formatter)

간단하지만 효과적입니다. 클로드가 답변을 마친 후, 수정된 모든 파일을 해당 저장소의 `.prettierrc` 설정에 맞춰 Prettier로 자동 포맷팅합니다. 더 이상 클로드가 지난주에 파일 만들 때 콤마 하나 빼먹었다고, 제가 파일을 수동으로 수정할 때마다 Prettier가 돌아가서 20군데씩 수정 사항이 생기는 걸 지켜볼 필요가 없습니다.

---

### ⚠️ 업데이트: 이 훅은 더 이상 추천하지 않습니다

글을 올린 후, 한 독자분이 파일 수정이 `<system-reminder>` 알림을 트리거하여 엄청난 양의 컨텍스트 토큰을 소모할 수 있다는 상세한 데이터를 공유해 주셨습니다. 그분의 경우, Prettier 포맷팅 때문에 시스템 리마인더가 파일 차이점(diff)을 계속 보여주는 바람에 단 3회 만에 **16만 토큰**이 소모되었다고 합니다.

프로젝트마다 영향은 다르겠지만(대용량 파일이나 엄격한 포맷팅 규칙이 있는 경우 최악의 시나리오가 됩니다), 저도 제 설정에서 이 훅을 제거했습니다. 어차피 파일을 수동으로 편집할 때 포맷팅이 되도록 두는 건 큰 일이 아니며, 잠재적인 토큰 비용을 생각하면 그 정도 편리함은 감수할 가치가 없습니다.

자동 포맷팅을 원하신다면 클로드와 대화하는 도중이 아니라, 세션 사이사이에 수동으로 Prettier를 실행하는 것을 고려해 보세요.

#### 훅 #4: 에러 핸들링 리마인더 (Error Handling Reminder)

앞서 언급했던 '부드러운 철학' 기반의 훅입니다:

* 클로드가 작업을 마친 후 수정된 파일들을 분석합니다.
* 위험 요소가 있는 패턴(`try-catch`, 비동기 작업, 데이터베이스 호출, 컨트롤러 등)을 감지합니다.
* 위험한 코드가 작성되었다면 부드러운 리마인더를 띄웁니다.
* 에러 핸들링이 필요한지 클로드가 스스로 판단하게 합니다.
* 작업을 차단하거나 방해(friction)하지 않습니다. 그저 인지(awareness)하게 할 뿐입니다.

Example output:
```
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
📋 ERROR HANDLING SELF-CHECK
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

⚠️  Backend Changes Detected
   2 file(s) edited

   ❓ Did you add Sentry.captureException() in catch blocks?
   ❓ Are Prisma operations wrapped in error handling?

   💡 Backend Best Practice:
      - All errors should be captured to Sentry
      - Controllers should extend BaseController
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
```

전체 훅 파이프라인 (The Complete Hook Pipeline)
현재 클로드의 모든 답변 과정에서 일어나는 일들은 다음과 같습니다:
```
클로드가 답변을 마침
↓
**훅 1: Prettier 포맷터 실행** → 모든 수정된 파일 자동 포맷팅
↓
**훅 2: 빌드 체크 실행** → TypeScript 에러 즉시 감지
↓
**훅 3: 에러 리마인더 실행** → 에러 핸들링에 대한 부드러운 자가 점검
↓
**에러 발견 시** → 클로드가 이를 확인하고 수정
↓
**에러가 너무 많은 경우** → 에러 자동 해결 에러전트(Auto-error-resolver agent) 추천
↓
**결과:** 깔끔하고 포맷팅된, 에러 없는 코드
```

그리고 `UserPromptSubmit` 훅 덕분에 클로드는 작업을 시작하기도 **전**에 관련 스킬들을 확실히 로드하게 됩니다.

뒤처리가 정말 완벽합니다. 아주 아름답죠.

---

### 스킬에 스크립트 첨부하기 (Scripts Attached to Skills)

깃허브의 앤스로픽 공식 스킬 예제에서 배운 정말 멋진 패턴이 하나 있습니다. 바로 **스킬에 유틸리티 스크립트를 첨부하는 것**입니다.

예를 들어, 제 `backend-dev-guidelines` 스킬에는 인증된 라우트를 테스트하는 방법에 대한 섹션이 있습니다. 단순히 인증이 어떻게 작동하는지 글로 설명하는 대신, 스킬에서 실제 스크립트를 참조하도록 설정했습니다.
```
### Testing Authenticated Routes

Use the provided test-auth-route.js script:


node scripts/test-auth-route.js http://localhost:3002/api/endpoint
```

이 스크립트는 다음과 같은 복잡한 인증 단계를 여러분 대신 처리해줍니다:

* Keycloak에서 리프레시 토큰 가져오기
* JWT 비밀 키(secret)로 토큰 서명하기
* 쿠키 헤더 생성
* 인증된 요청 보내기

클로드가 라우트를 테스트해야 할 때, 이제 어떤 스크립트를 어떻게 사용해야 하는지 정확히 알고 있습니다. 매번 "테스트 스크립트를 새로 만들게요"라며 바퀴를 재발명할 필요가 없어졌죠.

저는 이 패턴을 더 확장할 계획입니다. 관련 스킬에 더 많은 유틸리티 스크립트를 연결해서, 클로드가 매번 처음부터 도구를 생성하는 대신 이미 준비된 도구를 바로 꺼내 쓰게 만들 생각입니다.

---

### 도구 및 기타 유용한 것들 (Tools and Other Things)

#### Mac용 SuperWhisper

타이핑하느라 손이 지쳤을 때 프롬프트를 입력하기 위한 음성 인식(Voice-to-text) 도구입니다. 놀라울 정도로 잘 작동하며, 클로드는 제 두서없는 음성 입력을 기가 막히게 알아듣습니다.

#### Memory MCP

스킬 시스템이 "패턴 기억" 업무의 대부분을 가져가면서 사용 빈도는 줄었습니다. 하지만 스킬에 담기에는 적절치 않은 프로젝트 고유의 의사결정이나 아키텍처 선택 사항들을 추적하는 데는 여전히 유용합니다.

#### BetterTouchTool (BTT)

* **Cursor에서 상대 경로 복사 (코드 참조 공유용):** 저는 파일을 더 쉽게 찾기 위해 VSCode를 열어두곤 합니다. CAPS-LOCK을 두 번 누르면 BTT가 상대 경로 복사 단축키를 실행하고, 클립보드 내용 앞에 '@' 기호를 붙인 뒤, 터미널로 포커스를 옮겨 파일 경로를 붙여넣습니다. 이 모든 과정이 한 번에 처리됩니다.
* **앱 포커스 단축키:** 더블 탭으로 앱 간 빠른 전환 (CMD 두 번 = Claude Code, OPT 두 번 = 브라우저).
* **자주 쓰는 동작을 위한 커스텀 제스처:** 솔직히 앱들 사이를 헤매지 않아도 되는 시간만 아껴도 BTT 구매 비용은 뽑고도 남습니다.

#### 모든 것을 위한 스크립트

귀찮고 지루한 작업이 있다면, 높은 확률로 그것을 위한 스크립트가 존재합니다:

* **Mock 테스트 데이터 생성 CLI 도구:** Claude Code를 쓰기 전에는 테스트 데이터 하나를 만들려고 질문이 120개나 되는 폼을 일일이 제출해야 했습니다. 정말 짜증 나는 일이었죠.
* **인증 테스트 스크립트:** (토큰 획득, 라우트 테스트 등)
* **데이터베이스 초기화 및 시딩(Seeding)**
* **마이그레이션 전 스키마 차이(diff) 체크 도구**
* **개발용 DB 자동 백업 및 복구**

> **전문가 팁(Pro tip):** 클로드가 유용한 스크립트 작성을 도와주면, 즉시 `CLAUDE.md`에 기록하거나 관련 스킬에 첨부하세요. 미래의 당신이 과거의 당신에게 진심으로 고마워할 겁니다.

### 문서화 (여전히 중요하지만, 한 단계 진화했습니다)

기획 다음으로 중요한 것이 문서화라고 생각합니다. 저는 각 작업이나 기능별로 생성되는 개발 문서 외에도 진행 과정의 모든 것을 기록합니다. 시스템 아키텍처부터 데이터 흐름도, 실제 개발자 문서 및 API에 이르기까지 말이죠.

여기서 바뀐 점은 이겁니다. **이제 문서는 스킬을 대체하는 게 아니라 스킬과 '함께' 작동합니다.**

* **스킬(Skills) 포함 내용:** 재사용 가능한 패턴, 베스트 프랙티스, 가이드 (How-to)
* **문서(Documentation) 포함 내용:** 시스템 아키텍처, 데이터 흐름, API 레퍼런스, 통합 지점

**예시:**

* "컨트롤러 만드는 법" → `backend-dev-guidelines` 스킬
* "우리 워크플로우 엔진이 작동하는 방식" → **아키텍처 문서**
* "React 컴포넌트 작성법" → `frontend-dev-guidelines` 스킬
* "시스템 내 알림 흐름" → **데이터 흐름도 + 알림 스킬**

저는 여전히 엄청난 양의 문서(850개 이상의 마크다운 파일)를 보유하고 있지만, 이제 이 문서들은 스킬이 더 잘 처리할 수 있는 일반적인 베스트 프랙티스를 반복하는 대신 **프로젝트 고유의 아키텍처**에만 예리하게 집중하고 있습니다.

꼭 저처럼 광적으로 할 필요는 없지만, 여러 계층의 문서화를 구축하는 것은 강력히 추천합니다. 특정 서비스의 광범위한 아키텍처 개요를 다루는 문서를 만들고, 그 안에 아키텍처의 세부 부분으로 연결되는 경로를 포함하는 식이죠. 이렇게 하면 클로드가 여러분의 코드베이스를 훨씬 더 쉽게 탐색할 수 있게 됩니다.

---

### 프롬프트 팁 (Prompt Tips)

프롬프트를 작성할 때는 결과물로 원하는 바를 최대한 구체적으로 설명해야 합니다. 다시 한번 강조하지만, 최소한의 계획도 논의하지 않고 건축업자에게 화장실을 새로 지어달라고 하진 않겠죠?

> "맞아요! 화장실에 긴 털 카펫(shag carpet)을 까는 건 확실히 좋은 생각이 아니네요."

가끔 세부 사항을 잘 모를 수도 있는데, 그것도 괜찮습니다. 모를 때는 질문을 하거나, 클로드에게 직접 조사(research)를 해서 몇 가지 잠재적인 해결책을 제안해달라고 하세요. 별도의 서브에이전트나 다른 AI 채팅 인터페이스를 연구용으로 써도 좋습니다. 방법은 무궁무진합니다. 이렇게 하면 클로드가 만든 계획을 보고 이게 좋은지, 나쁜지, 수정이 필요한지 훨씬 더 명확하게 판단할 수 있기 때문에 결과적으로 큰 이득이 됩니다. 그렇지 않으면 아무것도 모른 채 비행하는, 순수하게 감에만 의존하는 '바이브 코딩'이 될 뿐입니다. 그러면 나중에는 어떤 파일이 수정하려는 내용과 관련이 있는지조차 몰라서 어떤 컨텍스트를 포함해야 할지 모르는 상황에 처하게 됩니다.

**정직하고 편향되지 않은 피드백을 원한다면 유도 심문을 피하세요.** 클로드가 한 작업이 확신이 서지 않을 때 "이거 좋아, 아냐?"라고 묻는 대신 중립적인 방식으로 물어보세요. 클로드는 사용자가 듣고 싶어 하는 말을 하는 경향이 있어서, 유도 질문은 답변을 왜곡할 수 있습니다. 상황을 설명하고 의견이나 대안을 묻는 편이 훨씬 균형 잡힌 답변을 얻는 길입니다.

### 에이전트, 훅, 슬래시 명령어 (삼위일체)

#### 에이전트 (Agents)

저는 각 분야에 특화된 작은 에이전트 군단을 구축했습니다.

**품질 관리 (Quality Control):**

* **code-architecture-reviewer:** 베스트 프랙티스 준수 여부를 검토합니다.
* **build-error-resolver:** TypeScript 에러를 체계적으로 해결합니다.
* **refactor-planner:** 포괄적인 리팩토링 계획을 수립합니다.

**테스트 및 디버깅 (Testing & Debugging):**

* **auth-route-tester:** 인증이 필요한 백엔드 라우트를 테스트합니다.
* **auth-route-debugger:** 401/403 에러 및 라우트 이슈를 디버깅합니다.
* **frontend-error-fixer:** 프론트엔드 에러를 진단하고 수정합니다.

**기획 및 전략 (Planning & Strategy):**

* **strategic-plan-architect:** 상세한 구현 계획을 수립합니다.
* **plan-reviewer:** 구현 전 계획을 검토합니다.
* **documentation-architect:** 문서를 생성하거나 업데이트합니다.

**특화 에이전트 (Specialized):**

* **frontend-ux-designer:** 스타일링 및 UX 이슈를 해결합니다.
* **web-research-specialist:** 웹상의 이슈 조사 및 다양한 정보를 탐색합니다.
* **reactour-walkthrough-designer:** UI 가이드 투어를 생성합니다.

에이전트 활용의 핵심은 **매우 구체적인 역할**을 부여하고, 어떤 결과물을 반환해야 하는지 명확한 지침을 주는 것입니다. 제가 뭘 고쳤는지 말도 안 해주고 무작정 "고쳤어요!"라고만 답하며 제멋대로 행동하는 에이전트들을 만들면서 뼈저리게 깨달은 점입니다.

#### **훅 (Hooks) — 위에서 다룬 내용 요약**

훅 시스템은 솔직히 이 모든 것을 하나로 묶어주는 핵심입니다. 훅이 없다면 다음과 같은 상황이 벌어집니다:

* 스킬(Skills)은 만들어놓고 쓰지도 않게 됩니다.
* 에러가 코드 사이로 빠져나갑니다.
* 코드 포맷팅이 제각각이 됩니다.
* 자동화된 품질 체크가 불가능합니다.

반면 훅을 사용하면:

* 스킬이 자동으로 활성화됩니다.
* 에러를 하나도 남기지 않습니다.
* 자동으로 포맷팅이 완료됩니다.
* 품질에 대한 인지 능력이 시스템에 내장됩니다.

---

#### **슬래시 명령어 (Slash Commands)**

꽤 많은 커스텀 슬래시 명령어를 만들어 뒀지만, 가장 자주 쓰는 것들은 다음과 같습니다:

**기획 및 문서화:**

* `/dev-docs`: 포괄적인 전략적 계획 수립
* `/dev-docs-update`: 대화 압축 전 개발 문서 업데이트
* `/create-dev-docs`: 승인된 계획을 개발 문서 파일로 변환

**품질 및 리뷰:**

* `/code-review`: 아키텍처 관점의 코드 리뷰
* `/build-and-fix`: 빌드 실행 후 모든 에러 수정

**테스트:**

* `/route-research-for-testing`: 영향을 받는 라우트 탐색 및 테스트 실행
* `/test-route`: 특정 인증 라우트 테스트

슬래시 명령어의 묘미는 명령어 하나가 방대한 프롬프트로 확장된다는 점입니다. 매번 같은 지침을 타이핑하는 대신, 간단한 명령어로 엄청난 양의 컨텍스트와 지시 사항을 전달할 수 있습니다.

---

### **결론 (Conclusion)**

6개월간 하드코어하게 사용하며 배운 점은 다음과 같습니다:

#### **필수 요소 (The Essentials):**

* **모든 것을 계획하세요:** 플래닝 모드나 `strategic-plan-architect`를 활용하세요.
* **스킬 + 훅:** 자동 활성화만이 스킬을 실제로 신뢰성 있게 작동시키는 유일한 방법입니다.
* **개발 문서 시스템:** 클로드가 맥락을 놓치는 것을 방지합니다.
* **코드 리뷰:** 클로드가 자신의 작업물을 스스로 리뷰하게 하세요.
* **백엔드용 PM2:** 디버깅을 견딜 만하게 만들어 줍니다.

#### **있으면 좋은 것들 (The Nice-to-Haves):**

* 공통 작업을 위한 특화된 에이전트들
* 반복되는 워크플로우를 위한 슬래시 명령어
* 포괄적인 문서화
* 스킬에 첨부된 유틸리티 스크립트
* 의사결정 추적을 위한 Memory MCP

지금 생각나는 건 여기까지입니다. 말씀드렸듯이 저도 그저 한 명의 개발자일 뿐입니다. 여러분의 팁과 요령, 혹은 비판도 언제든 환영합니다. 워크플로우를 개선하는 데는 늘 진심이니까요. 주변에 이런 이야기를 나눌 사람이 없어서(저희 팀은 규모가 작고 AI 도입에 아주 느린 편입니다) 이렇게 제가 효과를 본 방법들을 공유해보고 싶었습니다.

긴 글 읽어주셔서 감사합니다. 구현 세부 사항이나 궁금한 점이 있다면 기꺼이 공유하겠습니다. 특히 훅과 스킬 시스템은 제대로 작동시키기까지 시행착오가 많았지만, 한 번 구축해두니 이제는 그 전으로 돌아가는 건 상상조차 할 수 없네요.

**요약(TL;DR):** TypeScript 훅을 이용해 Claude Code 스킬 자동 활성화 시스템을 구축하고, 컨텍스트 손실 방지를 위한 개발 문서 워크플로우를 만들었으며, PM2와 자동 에러 체크를 도입했습니다. 결과적으로 6개월 만에 혼자서 일관된 품질로 30만 줄의 코드를 새로 짰습니다.
